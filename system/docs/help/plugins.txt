# Portabilitaet: UNIVERSAL
# Version: 2.0.0
# Zuletzt validiert: 2026-02-13 (Claude Opus 4.6)
# Naechste Pruefung: 2026-08-13

BACH PLUGIN-API
===============

Stand: 2026-02-13

Die Plugin-API ermoeglicht dynamische Erweiterung von BACH zur Laufzeit.
Plugins koennen Tools, Hooks, Workflows und Handler registrieren --
imperativ (via Code) oder deklarativ (via plugin.json).

CLI-BEFEHLE
-----------
  bach plugins list              Alle geladenen Plugins anzeigen
  bach plugins load <pfad>       Plugin aus plugin.json laden
  bach plugins unload <name>     Plugin entladen
  bach plugins tools             Alle Plugin-Tools anzeigen
  bach plugins info <name>       Details zu einem Plugin
  bach plugins create <name>     Plugin-Manifest erstellen (Scaffolding)
  bach plugins caps              Capability-Profile anzeigen
  bach plugins trust <name> <l>  Trust-Level eines Plugins aendern
  bach plugins audit [limit]     Letzte Capability-Pruefungen anzeigen

  Kurzform:
  bach plugin list               (Alias: plugin -> plugins)

API-NUTZUNG (Imperativ)
------------------------
  from core.plugin_api import plugins
  # Oder: from bach_api import plugins

  # Tool registrieren
  def mein_tool(text):
      return f"Verarbeitet: {text}"

  plugins.register_tool("mein_tool", mein_tool, "Beschreibung")
  result = plugins.call_tool("mein_tool", "Eingabe")

  # Hook registrieren
  def on_task(ctx):
      print(f"Task erstellt: {ctx['task_id']}")

  plugins.register_hook("after_task_create", on_task, plugin="mein-plugin")

  # Handler registrieren (neuer CLI-Befehl!)
  from hub.base import BaseHandler
  class MeinHandler(BaseHandler):
      ...

  plugins.register_handler("mein_cmd", MeinHandler, plugin="mein-plugin")

  # Workflow erstellen
  plugins.register_workflow("mein-workflow", "# Workflow\n...", plugin="mein-plugin")

  # Verwaltung
  print(plugins.list_plugins())
  plugins.unload_plugin("mein-plugin")

PLUGIN-MANIFEST (Deklarativ)
-----------------------------
Erstelle ein `plugin.json` fuer automatisches Laden:

  bach plugins create mein-plugin

Manifest-Format (plugin.json):
  {
    "name": "mein-plugin",
    "version": "1.0.0",
    "description": "Was das Plugin tut",
    "author": "claude",
    "source": "goldstandard",
    "capabilities": ["db_read", "hook_listen"],
    "hooks": [
      {
        "event": "after_task_done",
        "module": "handlers.py",
        "handler": "on_task_done",
        "priority": 50
      }
    ],
    "handlers": [
      {"name": "mein_cmd", "file": "mein_handler.py"}
    ],
    "workflows": [
      {"name": "mein-workflow", "file": "workflow.md"}
    ]
  }

Laden:
  bach plugins load plugins/mein-plugin/plugin.json

REGISTRIERUNGS-TYPEN
---------------------
  Typ          API-Methode              Beschreibung
  ---------    ----------------------   ---------------------------------
  Tool         register_tool()          Callable als Werkzeug registrieren
  Hook         register_hook()          Event-Listener registrieren
  Workflow     register_workflow()      Markdown-Datei erstellen
  Handler      register_handler()       Neuer CLI-Befehl zur Laufzeit

PLUGIN-LIFECYCLE
-----------------
  1. Erstellen:  bach plugins create <name>
  2. Entwickeln: plugin.json + handlers.py bearbeiten
  3. Laden:      bach plugins load <pfad/plugin.json>
  4. Nutzen:     Hooks feuern, Tools aufrufen, CLI-Befehle nutzen
  5. Entladen:   bach plugins unload <name>

CAPABILITY-SYSTEM (Stufe 1 Sandbox)
-------------------------------------
Plugins deklarieren benoetigte Faehigkeiten. BACH prueft und
durchsetzt basierend auf dem Trust-Level der Quelle.

  Definierte Capabilities:
    db_read          Datenbank lesen
    db_write         Datenbank schreiben
    file_read        Dateien lesen
    file_write       Dateien schreiben
    hook_listen      Auf Events lauschen
    hook_emit        Events emittieren
    tool_register    Neue Tools registrieren
    handler_register Neue CLI-Handler registrieren
    workflow_create  Workflows erstellen
    network          Netzwerk-Zugriff (HTTP/API)
    shell            Shell-Befehle ausfuehren

  Trust-Profile (verknuepft mit data/skill_sources.json):
    goldstandard     trust=100  Alle Capabilities
    trusted          trust=80   Alles ausser shell + network
    untrusted        trust=20   Nur db_read, file_read, hook_listen
    blacklist        trust=0    Nichts erlaubt

  Enforcement:
    - register_tool()     prueft 'tool_register'
    - register_hook()     prueft 'hook_listen'
    - register_handler()  prueft 'handler_register'
    - register_workflow() prueft 'workflow_create'
    - load_plugin()       prueft alle angeforderten Capabilities

  Audit:
    - Jede Pruefung wird in data/logs/capability_audit.log geschrieben
    - In-Memory Log (letzte 200 Eintraege): bach plugins audit
    - Hook 'after_capability_denied' feuert bei Verweigerung

SICHERHEIT
----------
  - Capability-Enforcement in allen register_*() Methoden
  - Trust-Level aus skill_sources.json (4-Stufen-System)
  - Statische Code-Analyse: eval, exec, subprocess, os.system
  - Audit-Log fuer Nachvollziehbarkeit
  - Fehlerhafte Hooks werden gefangen, brechen nichts ab
  - Plugin-Entladen entfernt alle Registrierungen sauber
  - Audit via: bach plugins audit, bach plugins info <name>

ARCHITEKTUR
-----------
  core/capabilities.py  CapabilityManager-Singleton (Enforcement)
  core/plugin_api.py    PluginRegistry-Singleton (Plugin-Verwaltung)
  hub/plugins.py        CLI-Handler (bach plugins ...)
  core/hooks.py         Hook-Framework (17 Events)
  data/skill_sources.json  Trust-Profile und Capability-Zuordnung

SIEHE AUCH
----------
  bach help hooks              Hook-Framework (16 Events)
  bach help skills             Skill-System
  bach help self-extension     Selbsterweiterungs-System
  bach help cli                CLI-Konventionen
