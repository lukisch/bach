# Portabilitaet: UNIVERSAL
# Version: 1.0.0
# Zuletzt validiert: 2026-02-08
# Naechste Pruefung: 2026-08-08

OPERATOREN-TAXONOMIE
====================
Vollstaendige Klassifikation der Datenverarbeitungs-Operatoren
fuer Watcher, Toolchains, Injektoren und Automatisierung.

Bezug: Lernsystem-Analyse (user/_archive/ANALYSE_Lernsysteme_BACH_vs_recludOS.md)


1. ERKENNUNGS-OPERATOREN ("Sinne")
===================================
Wie das System Veraenderungen in der Umwelt wahrnimmt.

1.1 Polling (periodisches Abfragen)
------------------------------------
Regelmaessiges Pruefen eines Zustands.
  - Verzeichnisinhalt bei t0 und t1 vergleichen
  - API alle 5 Minuten abfragen
  - Cron-Jobs fuer Systemmetriken
BACH: TimeInjector, Daemon-Checks, Session-Start-Scan

1.2 Event-Driven (Push-basiert)
-------------------------------
Reaktion auf externe Ereignisse.
  - Filesystem-Events (inotify)
  - Webhooks (GitHub, Stripe)
  - Message-Queues (Kafka, RabbitMQ)
BACH: Noch nicht implementiert. Toolchain-Events als erster Schritt.

1.3 Snapshot-Diffing
--------------------
Zwei Zustaende vergleichen und Abweichungen extrahieren.
  - Datei-Hashes vergleichen
  - Datenbank-Snapshot vs. Live-Daten
  - Konfigurations-Drift erkennen
BACH: RAG tools/rag/ingest.py (MD5 Change Detection), DirScan


2. ANALYSE-OPERATOREN
=====================
Wie das System Daten versteht und einordnet.

2.1 Vergleichen
---------------
Zwei oder mehr Werte gegenueberstellen.
  - Hash-Vergleich
  - Feld A == Feld B
  - Zeitstempel t0 < t1

2.2 Messen
----------
Quantitative Eigenschaften bestimmen.
  - Dateigroesse
  - Latenzzeit
  - CPU-Auslastung
  - Anzahl neuer Datensaetze

2.3 Filtern
-----------
Daten anhand von Regeln reduzieren.
  - Nur Dateien > 10 MB
  - Nur E-Mails mit Betreff "Rechnung"
  - Nur API-Antworten mit Status 200

2.4 Klassifizieren
------------------
Daten in Kategorien einordnen.
  - Spam vs. Nicht-Spam
  - Dokumenttyp erkennen (Rechnung, Vertrag, Mahnung)
  - Log-Level (INFO, WARN, ERROR)
BACH: OCR-Kategorisierung (Office Lens), Skill-Typen

2.5 Gruppieren
--------------
Daten nach Merkmalen zusammenfassen.
  - Logs nach Service gruppieren
  - Rechnungen nach Monat gruppieren
  - Dateien nach Dateityp gruppieren

2.6 Aggregieren
---------------
Gruppen zusammenfassen oder verdichten.
  - Summe aller Rechnungsbetraege
  - Durchschnittliche CPU-Last
  - Anzahl Dateien pro Ordner

2.7 Korrelieren
---------------
Beziehungen zwischen Datenpunkten erkennen.
  - Log-Events mit Request-ID verknuepfen
  - Sensorwert + Zeitstempel + Standort
  - Fehler + vorherige Systemlast
BACH: Assoziatives Memory (memory_associations)

2.8 Validieren
--------------
Pruefen, ob Daten Regeln erfuellen.
  - JSON-Schema-Validierung
  - IBAN-Pruefung
  - Pflichtfelder vorhanden?

2.9 Normalisieren
-----------------
Daten in ein einheitliches Format bringen.
  - Datumsformate vereinheitlichen
  - Gross-/Kleinschreibung angleichen
  - Waehrungsumrechnung


3. TRANSFORMATIONS-OPERATOREN
=============================
Wie das System Daten umwandelt.

3.1 Extrahieren
---------------
Informationen aus Rohdaten herausloesen.
  - OCR aus PDF
  - Regex aus Text
  - JSON-Felder aus API-Antwort
BACH: OCR-Pipeline, RAG Chunking

3.2 Transformieren
------------------
Daten in eine andere Form ueberfuehren.
  - CSV -> JSON
  - Text -> Tokens
  - Bild -> Thumbnail

3.3 Anreichern (Enrichment)
----------------------------
Daten mit zusaetzlichen Informationen ergaenzen.
  - Geo-Lookup (IP -> Land)
  - Kundendaten aus CRM ergaenzen
  - KI-basierte Klassifikation hinzufuegen
BACH: RAG Search (semantische Anreicherung)

3.4 Zusammenfuehren (Merge/Join)
---------------------------------
Mehrere Datenquellen kombinieren.
  - Tabellen per Schluessel verbinden
  - Logs aus mehreren Services zusammenfuehren
  - E-Mail + CRM-Eintrag matchen


4. ZEITBEZOGENE OPERATOREN
==========================

4.1 Sequenzieren
----------------
Reihenfolgen herstellen oder analysieren.
  - Sortieren nach Zeitstempel
  - Workflow-Schritte nacheinander ausfuehren
  - Ereignisfolgen rekonstruieren
BACH: Toolchain-Engine (hub/chain.py), Session-Reihenfolge

4.2 Fensterung (Windowing)
---------------------------
Daten in Zeitfenster einteilen.
  - 5-Minuten-Durchschnitt
  - Rolling Window fuer Sensorwerte
  - Sliding Window fuer Log-Analysen


5. KONTROLL-OPERATOREN
======================

5.1 Debouncing
--------------
Mehrere schnelle Ereignisse zu einem zusammenfassen.
  - Dateiaenderungen buendeln
  - UI-Events reduzieren
  - API-Requests throttlen

5.2 Rate-Limiting
-----------------
Begrenzen, wie oft etwas passieren darf.
  - Max. 10 API-Calls pro Minute
  - E-Mail-Benachrichtigungen drosseln
BACH: Token-Budget-Zonen (Konzept aus recludOS)

5.3 Retry-Strategien
--------------------
Wiederholungslogik bei Fehlern.
  - Exponentielles Backoff
  - Feste Retry-Intervalle
  - Retry bis Timeout


6. SPEICHER- UND ZUSTANDS-OPERATOREN
=====================================

6.1 Stateful Processing
------------------------
Vorherige Werte werden gespeichert.
  - Letzten Hash merken
  - Letzten API-Stand speichern
  - Sliding Window mit Zustand
BACH: Memory-System (alle 5 Schichten), Session-State

6.2 Stateless Processing
-------------------------
Jede Verarbeitung ist unabhaengig.
  - Hash einer Datei berechnen
  - JSON validieren
  - Regex-Match


7. META-OPERATOREN (hoehere Abstraktion)
=========================================

7.1 Orchestrieren
-----------------
Mehrere Operatoren zu einem Workflow verbinden.
  - n8n-Pipelines
  - Airflow DAGs
  - Kubernetes CronJobs + Worker
BACH: Toolchain-Engine (hub/chain.py), Workflows (skills/_protocols/), Dev-Zyklus

7.2 Optimieren
--------------
Datenverarbeitung effizienter machen.
  - Caching
  - Parallelisierung
  - Indexierung

7.3 Beobachten (Observability)
-------------------------------
Systemzustaende erfassen und interpretieren.
  - Logging
  - Metriken
  - Tracing
BACH: Session-Logging, Task-Statistik, Daemon-Status


8. OPERATOR-PATTERNS (Kombinationen)
=====================================
Typische Kombinationen von Operatoren fuer wiederkehrende Aufgaben.

8.1 Scoring & Ranking Pattern (#9)
-----------------------------------
Zweck: Elemente bewerten und sortieren.
Operatoren: Messen, Bewerten, Aggregieren, Sortieren.
  - E-Mails nach Relevanz sortieren
  - Dokumente nach "Wahrscheinlichkeit Rechnung" ranken

8.2 Classification Pipeline Pattern (#10)
------------------------------------------
Zweck: Daten in Klassen einteilen.
Operatoren: Extrahieren, Normalisieren, Klassifizieren, Validieren.
  - Dokumenttyp (Rechnung/Vertrag/Mahnung)
  - Ticket-Prioritaet (Low/Medium/High)

8.3 Rule-Based Filtering Pattern (#11)
---------------------------------------
Zweck: Ausschliessen anhand fester Regeln.
Operatoren: Filtern, Validieren, Ausschliessen.
  - Absender auf Blacklist
  - Dateien ohne Anhang verwerfen

8.4 Threshold Alert Pattern (#12)
----------------------------------
Zweck: Alarm bei Grenzwertueberschreitung.
Operatoren: Messen, Vergleichen, Bewerten, Event-Trigger.
  - CPU > 80%
  - mehr als 10 Fehler in 5 Minuten

8.5 Anomaly Detection Light Pattern (#13)
------------------------------------------
Zweck: Auffaellige Werte erkennen (einfach).
Operatoren: Messen, Aggregieren, Vergleichen, Fensterung.
  - Wert > Mittelwert + Faktor
  - ploetzlicher Sprung in Dateianzahl

8.6 Deduplication Pattern (#14)
--------------------------------
Zweck: Dubletten erkennen und entfernen.
Operatoren: Vergleichen, Gruppieren, Aggregieren, Filtern.
  - doppelte Rechnungen
  - doppelte E-Mails / IDs

8.7 Canonicalization Pattern (#15)
-----------------------------------
Zweck: Daten auf kanonische Form bringen.
Operatoren: Normalisieren, Transformieren, Validieren.
  - Namen, Adressen, Datumsformate vereinheitlichen

8.8 Golden Record Pattern (#16)
--------------------------------
Zweck: "beste" Version eines Datensatzes bestimmen.
Operatoren: Zusammenfuehren, Bewerten, Aggregieren, Validieren.
  - Kundendaten aus mehreren Systemen
  - Stammdatenpflege

8.9 Multi-Stage Validation Pattern (#17)
-----------------------------------------
Zweck: Validierung in Stufen.
Operatoren: Validieren, Klassifizieren, Filtern.
  - Syntax -> Semantik -> Geschaeftsregeln
  - "weich" vs. "hart" fehlerhafte Datensaetze

8.10 Fallback Resolution Pattern (#18)
---------------------------------------
Zweck: Alternative Wege bei Fehlern.
Operatoren: Testen, Retry, Fallback, Bewerten.
  - primaere API down -> sekundaere API
  - KI-Klassifikation unsicher -> Regelwerk

8.11 A/B Testing Pattern (#19)
-------------------------------
Zweck: Zwei Strategien gegeneinander testen.
Operatoren: Testen, Vergleichen, Bewerten, Aggregieren.
  - zwei Klassifikationsmodelle
  - zwei Regelsets fuer Mailrouting

8.12 Multi-Criteria Decision Pattern (#20)
-------------------------------------------
Zweck: Entscheidung nach mehreren Kriterien.
Operatoren: Messen, Bewerten, Aggregieren, Ranking.
  - "beste" Zuordnung zu Kostenstelle
  - Priorisierung von Tickets

8.13 Routing by Category Pattern (#21)
---------------------------------------
Zweck: Weiterleitung nach Kategorie.
Operatoren: Klassifizieren, Filtern, Routing.
  - Rechnungen -> Buchhaltung
  - Bewerbungen -> HR

8.14 Confidence-Based Handling Pattern (#22)
---------------------------------------------
Zweck: Verhalten abhaengig von Sicherheit/Score.
Operatoren: Bewerten, Klassifizieren, Filtern.
  - Score > 0.9 -> auto buchen
  - Score 0.6-0.9 -> manuelle Pruefung

8.15 Progressive Refinement Pattern (#23)
------------------------------------------
Zweck: Schrittweise Verfeinerung.
Operatoren: Klassifizieren, Anreichern, Transformieren.
  - grobe Kategorie -> feine Unterkategorie
  - erst Dokumenttyp, dann Inhaltsextraktion

8.16 Sanity Check Pattern (#24)
--------------------------------
Zweck: Einfache Plausibilitaetspruefungen.
Operatoren: Testen, Validieren, Ausschliessen.
  - Betrag > 0
  - Datum nicht in der Zukunft

8.17 Cross-Source Consistency Pattern (#25)
--------------------------------------------
Zweck: Daten gegen andere Quelle testen.
Operatoren: Vergleichen, Zusammenfuehren, Validieren.
  - Rechnungsbetrag vs. ERP
  - Kundennummer vs. CRM

8.18 Error Classification Pattern (#26)
----------------------------------------
Zweck: Fehlerarten kategorisieren.
Operatoren: Klassifizieren, Gruppieren, Aggregieren.
  - Netzwerkfehler vs. Datenfehler
  - Benutzerfehler vs. Systemfehler

8.19 Recovery Strategy Pattern (#27)
-------------------------------------
Zweck: Definierte Reaktion auf Fehler.
Operatoren: Testen, Retry, Fallback, Logging.
  - Queue -> Dead Letter Queue
  - manuelle Nachbearbeitungsliste

8.20 Human-in-the-Loop Pattern (#28)
-------------------------------------
Zweck: Mensch bei Unsicherheit einbinden.
Operatoren: Bewerten, Klassifizieren, Routing.
  - Score zu niedrig -> Review-Inbox
  - Konfliktfaelle -> Freigabeprozess


BEZUG ZUM LERNPROZESS
=====================
Die Operatoren bilden das Werkzeug-Set fuer alle 3 Modi:

  (1) Energiesparen: Polling + Filtern + Regeln abrufen
  (2) Nachdenken:    Korrelieren + Klassifizieren + Szenarien
  (3) Konsolidierung: Aggregieren + Normalisieren + Gruppieren

Erkennungs-Operatoren = Sinne (Wahrnehmung)
Analyse-Operatoren    = Verarbeitung (Denken)
Transformations-Op.   = Handeln (Aktion)
Meta-Operatoren       = Steuerung (Zentrale Exekutive)
Operator-Patterns     = Kombinierte Loesungsmuster


VERWANDTE HELP-DATEIEN
======================
  --help strategien      Kategorisieren, Bewerten, Ausschliessen, Testen
  --help denkstrategien  Kognitive Strategien (Chunking, Mustererkennung, etc.)
  --help rhetorik        Rhetorische Operatoren und Patterns
