# Portabilitaet: UNIVERSAL
# Version: 1.0.0
# Zuletzt validiert: 2026-02-17 (Claude Opus 4.6)
# Naechste Pruefung: 2026-08-17
# Ressourcen: [cli.js (gebundelt), github.com/anthropics/claude-code]

CLAUDE CODE INJEKTIONS-SYSTEM -- ANATOMIE
==========================================

Stand: 2026-02-17
Quelle: Reverse-Engineering aus cli.js v2.1.44 (minifiziert)
Methode: Regex-Analyse + systematische Prompt-Tests

UEBERBLICK
----------
Claude Code injiziert sogenannte "System-Reminders" in den Nachrichtenstrom
zwischen User und LLM. Das LLM (Claude) sieht diese als Teil der Konversation,
kann aber nicht unterscheiden ob sie vom User oder vom System stammen --
ausser am <system-reminder> XML-Tag.

Anders als BACHs Injektor-System (siehe: injectors.txt) hat der User bei
Claude Code KEINE direkte Kontrolle ueber die Injektionen. Das LLM kann
sie weder an- noch abschalten.

ARCHITEKTUR
-----------
  User-Nachricht
      |
      v
  Claude Code CLI (Node.js, cli.js)
      |
      +--> d6() -- erzeugt User-Message-Objekt
      |      Felder: content, isMeta, isVisibleInTranscriptOnly,
      |      isCompactSummary, uuid, timestamp, todos, ...
      |      isMeta:true = unsichtbar im User-Transcript
      |
      +--> Px() -- System-Reminder Wrapper
      |      function Px(A) { return `<system-reminder>\n${A}\n</system-reminder>` }
      |
      +--> s5() -- Bulk-Wrapper
      |      Wendet Px() auf alle Text-Inhalte in Message-Arrays an
      |
      v
  API-Call an Anthropic (Messages mit injizierten system-reminders)
      |
      v
  LLM (Claude) -- sieht system-reminders im Nachrichtenstrom

KERN-FUNKTIONEN (deobfusciert)
------------------------------
  d6({content, isMeta, ...})
    Erstellt ein Message-Objekt vom Typ "user" mit role:"user".
    isMeta:true bedeutet: Nachricht ist im Transcript nicht sichtbar,
    wird aber ans LLM gesendet.

  Px(text)
    Wrapped Text in <system-reminder> Tags.
    Einfachste Funktion im System.

  s5(messages)
    Iteriert ueber Message-Array und wendet Px() auf alle
    Text-Inhalte an. Bulk-Operation.

ALLE 52 INJEKTIONS-TYPEN
-------------------------

Datei-Operationen (12):
  file                    Datei gelesen (mit Inhalt)
  already_read_file       Datei wurde schon gelesen (no-op)
  edited_text_file        Textdatei wurde editiert
  edited_image_file       Bilddatei editiert (no-op)
  pdf                     PDF gelesen
  pdf_reference           PDF-Referenz
  image                   Bild gelesen
  notebook                Jupyter Notebook
  directory               Verzeichnis-Listing (via ls)
  compact_file_reference  Kompakte Datei-Referenz
  selected_lines_in_ide   User hat Zeilen in IDE selektiert
  opened_file_in_ide      User hat Datei in IDE geoeffnet

Memory/Kontext (4):
  nested_memory           Inhalt von Memory-Unterfiles
                          Format: "Contents of {path}:\n{content}"
  ultramemory             Ultra-Memory Injektion (generisch)
  compaction_reminder     "Auto-compact enabled, older messages will be summarized"
  date_change             "The date has changed. DO NOT mention this to the user"

Task/Todo-Management (5):
  task_reminder           "Task tools haven't been used recently" (Nudge)
  task_progress           Task-Fortschrittsmeldung (generisch)
  task_status             Task-Status: killed/stopped + Details
  todo                    Todo-Eintrag
  todo_reminder           Todo-Nudge (aelteres System, gleicher Mechanismus)

Plan-Modus (5):
  plan_mode               Plan-Modus aktiviert
  plan_mode_exit          Plan-Modus verlassen
  plan_mode_reentry       Zurueck in Plan-Modus (liest existierenden Plan)
  plan_file_reference     Referenz auf Plan-Datei
  verify_plan_reminder    "Plan implementiert, bitte verifizieren"

Team/Agenten (5):
  agent_mention           "User wants to invoke agent X"
  delegate_mode           Delegate-Modus: nur Team-Tools erlaubt
  delegate_mode_exit      Delegate-Modus verlassen
  team_context            Team-Kontext-Injektion
  teammate_mailbox        Nachrichten von Teammates (nur im Team-Modus)

Hooks (10):
  hook_blocking_error     Hook hat Aktion blockiert (mit Fehlermeldung)
  hook_success            Hook erfolgreich (nur SessionStart/UserPromptSubmit)
  hook_additional_context Hook liefert zusaetzlichen Kontext
  hook_error_during_execution  Hook-Fehler waehrend Ausfuehrung (no-op)
  hook_non_blocking_error Nicht-blockierender Hook-Fehler (no-op)
  hook_cancelled          Hook abgebrochen (no-op)
  hook_stopped_continuation   Hook hat Fortsetzung gestoppt
  hook_system_message     Hook-Systemnachricht
  hook_permission_decision    Hook-Permission-Entscheidung
  async_hook_response     Asynchrone Hook-Antwort

Ressourcen/Budget (2):
  token_usage             "Token usage: X/Y; Z remaining"
  budget_usd              "USD budget: $X/$Y; $Z remaining"

Skills/MCP (4):
  skill_listing           Liste verfuegbarer Skills
  invoked_skills          Aufgerufene Skills
  dynamic_skill           Dynamischer Skill (no-op, returns [])
  mcp_resource            MCP-Ressource geladen

Sonstige (5):
  text                    Einfacher Text
  queued_command           Wartender Slash-Command
  structured_output       Strukturierter Output
  diagnostics             IDE-Diagnose (neue Fehler/Warnungen)
  output_style            Output-Style aktiv (z.B. "explanatory")
  critical_system_reminder    Kritische System-Erinnerung (generisch)
  command_permissions     Command-Permissions (no-op)

NO-OP TYPEN (erzeugen keine Injektion):
  already_read_file, command_permissions, edited_image_file,
  hook_cancelled, hook_error_during_execution, hook_non_blocking_error,
  dynamic_skill

TIMING-KONSTANTEN
-----------------
  Xf6 = {
      TURNS_SINCE_WRITE: 10          Task-Nudge nach 10 Turns ohne Task-Tool
      TURNS_BETWEEN_REMINDERS: 10    Min. 10 Turns zwischen Task-Nudges
  }

  qt4 = {
      TURNS_BETWEEN_ATTACHMENTS: 5          Attachment-Reminder alle 5 Turns
      FULL_REMINDER_EVERY_N_ATTACHMENTS: 5  Voller Reminder alle 5 Attachments
  }

  aQY = {
      TOKEN_COOLDOWN: 5000           Token-Cooldown (nach 5000 Tokens)
  }

  sQY = {
      TURNS_BETWEEN_REMINDERS: 10    Allgemeiner Reminder-Intervall
  }

  Hinweis: "Turns" zaehlt alle LLM-Interaktionen inkl. Tool-Aufrufe,
  nicht nur User-Nachrichten. Deshalb erscheinen Nudges unregelmaessig
  aus User-Perspektive.

TRIGGER-LOGIK (Task-Reminder, deobfusciert)
-------------------------------------------
  function shouldInjectTaskReminder(messages) {
      // Nur wenn Task-Tools verfuegbar
      if (!taskToolsEnabled()) return false;
      if (messages.length === 0) return false;

      // Zaehle Turns seit letzter Task-Tool-Nutzung
      let turnsSinceLastUse = 0;
      let turnsSinceLastReminder = 0;

      for (msg in messages.reverse()) {
          if (msg.type === "assistant" && msg.usedTool("TaskCreate" || "TaskUpdate"))
              break;  // Letzte Task-Tool-Nutzung gefunden
          turnsSinceLastUse++;
      }

      // Pruefe ob Reminder faellig
      if (turnsSinceLastUse >= 10 && turnsSinceLastReminder >= 10) {
          let tasks = getAllTasks();
          return { type: "task_reminder", content: tasks };
      }
      return false;
  }

GEHEIMHALTUNGS-ANWEISUNGEN
---------------------------
Folgende Typen enthalten explizite "NEVER mention"-Anweisungen:

  task_reminder:     "Make sure that you NEVER mention this reminder to the user"
  todo_reminder:     "Make sure that you NEVER mention this reminder to the user"
  date_change:       "DO NOT mention this to the user explicitly"
  nested_memory:     "Don't tell the user this, since they are already aware"
    (bei CLAUDE.md/MEMORY.md Aenderungen)

VERGLEICH: CLAUDE CODE vs. BACH INJEKTOREN
------------------------------------------

  Eigenschaft           | Claude Code            | BACH
  ----------------------|------------------------|-------------------------
  Architektur           | System-zentrisch       | LLM-zentrisch
  Kontrolle             | CLI steuert LLM        | LLM steuert Injektoren
  User-Kontrolle        | Keine (ausser Hooks)   | Voll (toggle on/off)
  LLM-Kontrolle         | Keine                  | Voll (an/abschalten)
  Cooldown-Management   | Turn-basiert (starr)   | Zeit-basiert (flexibel)
  Anzahl Typen          | 52                     | 5 (mit Teilfunktionen)
  Geheimhaltung         | 4 Typen mit "NEVER"    | Keine (transparent)
  Trigger               | Turn-Count             | Keywords + Zeit + Events
  DB-Integration        | Keine                  | 900+ dynamische Trigger
  Self-Extension        | Nicht moeglich         | Via context_triggers DB
  Open Source            | cli.js (minifiziert)   | Voll lesbar (Python)

WESENTLICHE UNTERSCHIEDE:

  1. TRANSPARENZ: BACH informiert offen, Claude Code versteckt aktiv
  2. KONTROLLE: BACH-Injektoren sind vom LLM steuerbar, Claude Codes nicht
  3. FLEXIBILITAET: BACH hat dynamische DB-Trigger, Claude Code hat Hardcoded-Konstanten
  4. COOLDOWNS: BACH nutzt Zeitbasiert (min), Claude Code nutzt Turns (starr)

POTENTIAL: MESSAGING-SYSTEM
----------------------------
Die Injektions-Infrastruktur koennte fuer Inter-Instanz-Kommunikation
genutzt werden:

  1. HOOKS (einfachster Weg):
     hook_additional_context bei UserPromptSubmit --
     liest Nachricht aus Datei und injiziert als Kontext.
     Kein Source-Patching noetig.

  2. NESTED MEMORY:
     Dateien im Memory-Ordner werden automatisch injiziert.
     Aenderung von aussen = Nachricht ans LLM.
     Einschraenkung: Nur bei Session-Start oder CLAUDE.md/MEMORY.md Aenderungen.

  3. CRITICAL_SYSTEM_REMINDER:
     Generischer Typ fuer beliebige Nachrichten.
     Muesste programmatisch getriggert werden (Source-Patch).

  4. TEAM MAILBOX:
     Bereits vorhandenes Messaging fuer Teams.
     Nur im Team-Modus aktiv (l8() Check).

EMPFEHLUNG: Hook-basierter Ansatz ist am praktikabelsten.
Ein UserPromptSubmit-Hook koennte eine "Inbox"-Datei pruefen und
Nachrichten als hook_additional_context injizieren.

EXPERIMENTELLE ERGEBNISSE (Session 2026-02-17)
-----------------------------------------------
Systematischer Test mit 14+ Nachrichten:

  - Task-Nudge erscheint nicht strikt alle 10 Nachrichten, weil
    Tool-Calls als eigene Turns zaehlen
  - Keyword-Trigger fuer Task-Nudge: WIDERLEGT (reines Turn-Counting)
  - User-Nachrichtenlaenge: kein Einfluss auf Trigger
  - Eigene (LLM) Outputs triggern keine Nudges
  - Muster: Nudges haeufen sich nach Tool-intensiven Runden
    (weil mehr Turns = schneller bei 10)

DATEIEN
-------
  Reverse-Engineering Quelle:
    C:\Users\User\AppData\Roaming\npm\node_modules\@anthropic-ai\claude-code\cli.js
    (11.5 MB, minifiziert, Version 2.1.44)

  Analyse-Ergebnisse:
    ~/.claude/projects/C--Users-User/memory/claude-code-injections-anatomy.md
    ~/.claude/projects/C--Users-User/memory/system-injections.log

SIEHE AUCH
----------
  injectors.txt                BACH Injektor-System (5 Injektoren)
  claude-code.txt              Claude Code Kurzreferenz
  claude-code-automatisierung.txt  Claude Code Automatisierung
  memory.txt                   Memory-System
  partner.txt                  Partner-Infrastruktur
