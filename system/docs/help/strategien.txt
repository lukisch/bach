# Portabilitaet: UNIVERSAL
# Version: 1.0.0
# Zuletzt validiert: 2026-02-08
# Naechste Pruefung: 2026-08-08

STRATEGIEN
==========
Grundlegende Handlungsstrategien fuer Problemloesung und Automatisierung.

Bezug: docs/docs/docs/help/operatoren.txt, docs/docs/docs/help/denkstrategien.txt


1. KATEGORISIEREN
=================
Strategie: Regeln, Heuristiken oder Modelle ordnen Daten Klassen zu.
Operatoren: Extrahieren -> Normalisieren -> Klassifizieren -> Validieren

Beispiel (Python):
```python
def classify_doc(doc):
    text = doc["text"].lower()
    if "rechnung" in text:
        return "invoice"
    if "vertrag" in text:
        return "contract"
    return "other"
```


2. BEWERTEN (Scoring)
=====================
Strategie: Kriterien definieren, gewichten, Score berechnen.
Basis fuer Ranking, Automatisierung, Human-Review.

Beispiel (Python):
```python
def score_invoice(mail):
    score = 0
    if "rechnung" in mail["subject"].lower():
        score += 0.5
    if any(a.endswith(".pdf") for a in mail["attachments"]):
        score += 0.3
    if "iban" in mail["body"].lower():
        score += 0.2
    return score
```


3. AUSSCHLIESSEN
================
Strategie: Negativkriterien definieren (Blacklists, Muster, Grenzen).
Fruehzeitiges "Cut-off" reduziert Rauschen.

Beispiel (JavaScript):
```javascript
function isExcluded(mail) {
  const blacklist = ["noreply@", "newsletter@"];
  return blacklist.some(b => mail.from.includes(b));
}

const relevant = mails.filter(m => !isExcluded(m));
```


4. TESTEN (Validieren)
======================
Strategie: Daten gegen Regeln, Schemata, Referenzquellen pruefen.
Varianten: Schema-Tests, Business-Regeln, A/B-Vergleich, Cross-Source-Check.

Beispiel - Schema-Test (Python):
```python
def validate_invoice(d):
    tests = [
        ("amount", lambda x: x is not None and x > 0),
        ("invoice_number", lambda x: bool(x)),
        ("date", lambda x: x is not None),
    ]
    errors = []
    for field, rule in tests:
        if not rule(d.get(field)):
            errors.append(field)
    return errors
```

Beispiel - A/B-Test (Python):
```python
def classify_A(doc): ...
def classify_B(doc): ...

resA = classify_A(doc)
resB = classify_B(doc)

if resA != resB:
    # Konflikt markieren, fuer Analyse loggen
    pass
```


5. PROBLEME DEFINIEREN
======================
Strategie: Problem als Input -> gewuenschter Output -> Constraints formulieren.
In Code: klare Schnittstellen, erwartete Invarianten, Fehlerklassen.

Beispiel-Formulierung:
  Problem: "Eingehende E-Mails sollen automatisch als Rechnung,
           Vertrag oder Sonstiges klassifiziert werden."
  Input:   E-Mail (Betreff, Body, Anhaenge, Metadaten)
  Output:  Kategorie + Score + ggf. Extrakte
  Constraints: keine False-Positives bei Rechnungen ueber X EUR,
               Score-Schwellen, Logging


6. PROBLEMLOESE-STRATEGIEN
==========================
Generisches Muster fuer strategie-basierte Entscheidungen.

```python
def solve_problem(input_data, strategies):
    """
    strategies: Liste von Strategien mit:
      - name
      - condition(input_data) -> bool
      - action(input_data) -> result
    """
    for s in strategies:
        if s["condition"](input_data):
            return {
                "strategy": s["name"],
                "result": s["action"](input_data)
            }
    return {
        "strategy": None,
        "result": None
    }
```

Beispiel-Strategien (Confidence-Based):
```python
strategies = [
    {
        "name": "high_confidence_auto",
        "condition": lambda d: d["score"] >= 0.9,
        "action": lambda d: {"mode": "auto", "route": "buchhaltung"}
    },
    {
        "name": "medium_confidence_review",
        "condition": lambda d: 0.6 <= d["score"] < 0.9,
        "action": lambda d: {"mode": "review", "route": "inbox_review"}
    },
    {
        "name": "low_confidence_ignore",
        "condition": lambda d: d["score"] < 0.6,
        "action": lambda d: {"mode": "ignore", "route": None}
    },
]
```


BEZUG ZU BACH
=============
Diese Strategien sind die Basis fuer:
  - Injektoren (Kontext-basierte Entscheidungen) - system/tools/injectors.py
  - Memory-Konsolidierung (Lesson-Ableitung) - system/hub/consolidation.py
  - Workflow-Routing (Skills und Services)
  - Dokumenten-Verarbeitung (OCR, Klassifikation)

Strategien + Operatoren = wiederverwendbare Loesungsbausteine


VERWANDTE HELP-DATEIEN
======================
  --help operatoren      Basis-Operatoren und Patterns
  --help denkstrategien  Kognitive Strategien
  --help rhetorik        Rhetorische Operatoren
