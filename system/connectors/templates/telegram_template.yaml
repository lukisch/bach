# Template-Konfiguration fuer Telegram-basierte Connectors
# Diese Datei wird vom Setup-Wizard verwendet

connector_name: Telegram
connector_type: telegram
connector_display_name: Telegram Bot API
connector_description: |
  Implementiert BaseConnector fuer Telegram Bot API.
  Benoetigt: Bot-Token von @BotFather

# Module und Klassen-Namen
connector_module: telegram_connector
connector_instance_name: telegram_main
recipient_example: "chat_id"

# Auth-Konfiguration
auth_type: api_key
auth_config_example: |
  {"bot_token": "123456:ABC-DEF..."}
options_example: |
  {"owner_chat_id": "123456789"}

# API-Konfiguration
api_base_comment: "# Telegram Bot API"
api_base_url: "https://api.telegram.org/bot{token}/{method}"

# Code-Snippets
init_variables: |
  self._bot_token = config.auth_config.get("bot_token", "")
  self._owner_chat_id = str(config.options.get("owner_chat_id", ""))
  self._last_update_id = int(config.auth_config.get("last_update_id", 0))
  self._bot_info = None

connect_validation: |
  if not self._bot_token:
      self._status = ConnectorStatus.ERROR
      return False

connect_implementation: |
  result = self._api_call("getMe")
  if result:
      self._bot_info = result

send_message_implementation: |
  params = {
      "chat_id": recipient or self._owner_chat_id,
      "text": content,
      "parse_mode": "Markdown"
  }
  result = self._api_call("sendMessage", params)
  if result is None:
      # Retry ohne Markdown bei Parse-Fehlern
      params = {"chat_id": recipient or self._owner_chat_id, "text": content}
      result = self._api_call("sendMessage", params)

  return result is not None

get_messages_implementation: |
  params = {
      "offset": self._last_update_id + 1,
      "limit": min(limit, 100),
      "timeout": 30
  }
  result = self._api_call("getUpdates", params, timeout=40)
  if not result:
      return []

parse_messages_implementation: |
  for update in result:
      self._last_update_id = max(self._last_update_id, update.get("update_id", 0))

      msg = update.get("message")
      if not msg:
          continue

      chat = msg.get("chat", {})
      sender_id = str(chat.get("id", ""))

      # Owner-Filter
      if self._owner_chat_id and sender_id != self._owner_chat_id:
          continue

      content = msg.get("text", "")
      if not content:
          continue

      messages.append(Message(
          channel="telegram",
          sender=sender_id,
          content=content,
          timestamp=datetime.fromtimestamp(msg.get("date", 0)).isoformat(),
          direction="in",
          message_id=str(msg.get("message_id", "")),
          metadata={"update_id": update.get("update_id", 0)}
      ))

helper_methods: |
  def _api_call(self, method: str, params: dict = None, retries: int = 3, timeout: int = 15) -> any:
      """Telegram Bot API aufrufen."""
      url = self.API_BASE.format(token=self._bot_token, method=method)

      for attempt in range(retries):
          if params:
              data = json.dumps(params, ensure_ascii=False).encode("utf-8")
              req = urllib.request.Request(
                  url, data=data,
                  headers={"Content-Type": "application/json; charset=utf-8"})
          else:
              req = urllib.request.Request(url)

          try:
              with urllib.request.urlopen(req, timeout=timeout) as resp:
                  body = json.loads(resp.read().decode("utf-8"))
                  if body.get("ok"):
                      return body.get("result")
                  return None
          except Exception as e:
              if attempt == retries - 1:
                  print(f"[Telegram API Error] {method}: {e}", file=sys.stderr)
              return None

      return None

# Setup-Wizard Fragen
setup_questions:
  - name: bot_token
    prompt: "Bot-Token von @BotFather"
    type: secret
    required: true
    storage: auth_config

  - name: owner_chat_id
    prompt: "Owner Chat-ID (optional, fuer Nachrichten-Filter)"
    type: text
    required: false
    storage: options

  - name: default_channel
    prompt: "Default Channel/Chat-ID fuer Nachrichten"
    type: text
    required: false
    storage: options
