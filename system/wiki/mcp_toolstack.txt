# Portabilitaet: UNIVERSAL
# Zuletzt validiert: 2026-02-15 (Claude)
# Naechste Pruefung: 2026-08-15
# Quellen: [https://builder.io/blog/best-mcp-servers-2026], [https://github.com/wong2/awesome-mcp-servers], [https://github.com/voicetreelab/lazy-mcp], [https://github.com/metatool-ai/metamcp]

MCP TOOLSTACK - KURATIERTE AUSWAHL
===================================

Stand: 2026-02-15

Ergebnis einer systematischen Recherche und Filterung von 33 MCP-Servern.
Kriterien: Sicherheit, Kosten, Ersetzbarkeit, Redundanz, Claude-Code-Abdeckung.

KERNERKENNTNIS: BACH ALS MASTER-MPC
------------------------------------
BACH ist selbst ein Master-MPC-Server. Es hat eigene Tool-Discovery, ein
Registry-System (73 Handler, 322 Tools) und Claude nutzt BACH direkt via
bash -> python. Der MPC-Layer ist fuer lokale Services ueberfluessig —
BACH IST die Fernbedienung UND der Fernseher.

  Klassisch:   Claude -> MPC-Wrapper -> Service (fremd)
  BACH-Weg:    Claude -> Bash -> BACH-Tool -> Service (eigen, lokal, auditiert)

MPC bleibt nur relevant fuer:
  - Remote-Services die nicht lokal laufen koennen/sollen
  - Multi-Host-Betrieb (Claude + Gemini + andere auf demselben Service)
  - Tool-Sammlungen so gross dass Lazy-Loading noetig wird

FINALE FUNKTIONSMATRIX (10 BEREICHE)
-------------------------------------
  #   Funktion                  Frueherer MPC          Finale Umsetzung
  1   Echtzeit-Referenzen       Context7               BACH: bach docs search — Crawler+SQLite
  2   Webseiten-Parsing         Jina Reader            BACH: bach web parse — requests+bs4+markdownify
  3   Isolierte-Codeausf.       E2B                    BACH: bach sandbox run — Docker lokal
  4   Browser-Steuerung         Playwright             BACH: bach web scrape — playwright Python-Lib
  5   Schnittstellendoku        Apidog                 NATIV: Claude liest OpenAPI via Read-Tool
  6   Nachrichtenversand        Slack MCP              BACH: bach notify slack — slack_sdk lokal
  7   Cloud-Datenbank           Supabase MCP           BACH: bach db query — PostgreSQL/SQLite lokal
  8   Tool-Lazy-Loading         Lazy-MCP               ENTFAELLT: BACH hat eigene Tool-Discovery
  9   Server-Buendelung         MCP Proxy Server       ENTFAELLT: Keine MPC-Server zu buendeln
  10  Zugriffskontrolle         MCP Gateway Registry   ENTFAELLT: Alles lokal, kein Auth noetig

Verteilung: 7x BACH-Tool | 1x Nativ Claude | 2x Entfaellt (BACH-Architektur)
MPC-Server extern gebraucht: 0

URSPRUENGLICHE MPC-AUSWAHL (UEBERHOLT)
----------------------------------------
Dokumentiert die Zwischenergebnisse der Recherche bevor BACH-Integration
als ueberlegene Alternative erkannt wurde.

  #   Name                    Funktion               Sicherheit  Kosten  Ersetzbarkeit
  1   Context7                Echtzeit-Referenzen     9           ++      7
  5   E2B                     Isolierte-Codeausf.     7           +-      6
  10  Supabase MCP            Cloud-Datenbank         6           +-      8
  11  Lazy-MCP                Tool-Lazy-Loading       5           ++      5
  12  MCP Proxy Server        Server-Buendelung       3           ++      4
  13  MCP Gateway Registry    Zugriffskontrolle       5           ++      6

Index-Legende:
  Sicherheit (0-10)    10=hoechste Sicherheit, 0=gefaehrlich. Inkl. Ersteller-Reputation.
  Kosten               ++=komplett kostenlos (Open Source), +-=Free-Tier mit Limits
  Ersetzbarkeit (0-10) 0=trivial durch lokale Scripts ersetzbar, 10=extrem schwer

BACH-TOOL UMSETZUNGEN
---------------------

A) Echtzeit-Referenzen (ersetzt Context7)
   Konzept: Scheduled Crawler sucht aktuelle Docs, speichert in SQLite.
   BACH-Tool: bach docs search "query"
   DB: docs_index.db (library | version | endpoint | beschreibung | beispiel | url | datum)
   Crawler: WebSearch/Scraping fuer definierte Libraries, cron-gesteuert

B) Webseiten-Parsing (ersetzt Jina Reader)
   pip install requests beautifulsoup4 markdownify

   import requests
   from bs4 import BeautifulSoup
   from markdownify import markdownify as md

   def url_to_markdown(url):
       html = requests.get(url).text
       soup = BeautifulSoup(html, "html.parser")
       for tag in soup(["script", "style", "nav", "footer"]):
           tag.decompose()
       return md(str(soup.body or soup))

C) Isolierte-Codeausfuehrung (ersetzt E2B)
   Konzept: Docker-Container lokal, kein Netzwerk, RAM-limitiert, Auto-Timeout.
   BACH-Tool: bach sandbox run code.py
   Befehl: docker run --rm --network=none --memory=256m --timeout=30s python:3.12-slim

D) Browser-Steuerung (ersetzt Playwright MCP)
   pip install playwright && playwright install chromium

   from playwright.sync_api import sync_playwright

   def scrape(url, selector=None):
       with sync_playwright() as p:
           browser = p.chromium.launch()
           page = browser.new_page()
           page.goto(url)
           content = page.locator(selector).inner_text() if selector else page.content()
           browser.close()
           return content

E) Schnittstellendokumentation (ersetzt Apidog)
   Claude liest OpenAPI-Specs direkt via Read-Tool.
   Versteht Endpoints, Schemas, Parameter nativ.
   Kein zusaetzliches Tool noetig.

F) Nachrichtenversand (ersetzt Slack MCP/Composio)
   pip install slack_sdk

   from slack_sdk import WebClient

   def send_slack(channel, text, token):
       client = WebClient(token=token)
       client.chat_postMessage(channel=channel, text=text)

   Token in .env speichern, nie committen.
   Sicherer als Composio-Routing (kein Drittanbieter-Token-Weiterleitung).

G) Datenbank-Backend (ersetzt Supabase MPC)
   Konzept: Lokales PostgreSQL oder SQLite als Backend.
   BACH-Tool: bach db query "SQL"
   Optional: Self-hosted Supabase via Docker fuer Auth+Storage+Realtime.
   Minimalloesung: bach.db (SQLite) ist bereits vorhanden.

SIEHE AUCH
----------
wiki/mcp.txt               MPC Protokoll Uebersicht + alle recherchierten Server
wiki/zapier_mcp.txt         Zapier MPC im Detail
wiki/claude-code.txt        Claude Code Integration
wiki/was_ist_bach.txt       BACH System Uebersicht
