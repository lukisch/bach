RALPHING / RALPH LOOP - AUTONOME AI-AGENT PATTERN
=================================================

Stand: 2026-01-24

QUELLEN
-------
  Web-Recherche durchgefuehrt am 2026-01-24:
  - VentureBeat: How Ralph Wiggum went from The Simpsons to AI
  - Medium (AI Artistry): Ralph Loop for Deep Agents
  - DEV Community: 2026 - The year of the Ralph Loop Agent
  - Alibaba Cloud: From ReAct to Ralph Loop
  - GitHub: snarktank/ralph, vercel-labs/ralph-loop-agent
  - ghuntley.com: everything is a ralph loop

WAS IST RALPHING?
-----------------
"Ralph Mode" oder "Ralphing" ist ein autonomes Looping-Pattern fuer
Deep Agents. Es ermoeglicht einem KI-Agent kontinuierlich zu laufen,
wobei er bei jeder Iteration mit frischem Kontext neu startet und
das Dateisystem als Langzeitgedaechtnis nutzt.

Der Name stammt von Ralph Wiggum aus "The Simpsons" - ein Charakter,
der trotz seiner Einfachheit hartnackig und unerschuetterlich ist.

URSPRUNG
--------
  Erfinder:   Geoffrey Huntley (Open-Source-Entwickler, Australien)
  Zeitraum:   ~Mai 2025
  Loesung:    5-Zeilen Bash-Script als "elegante Brutalitaet"

  Kernidee: Ein unendlicher Loop, der wiederholt denselben Prompt
            an einen KI-Coding-Agent sendet.

  Der Clou: Der Fortschritt bleibt NICHT im LLM-Kontext - er lebt
            in den Dateien und der Git-History. Wenn der Kontext
            voll ist, startet ein frischer Agent und setzt dort
            fort, wo der letzte aufgehoert hat.

SO FUNKTIONIERT ES
------------------
  Grundprinzip:
    while true; do
      llm "Arbeite an der Aufgabe bis fertig"
    done

  Fortschrittsspeicherung:
    - GIT als Memory-Layer (commits, branches)
    - Dateisystem fuer Zwischenergebnisse
    - task.md oder PRD als Checkliste

  Context-Reset:
    - Wenn LLM-Kontext voll -> frischer Start
    - Neuer Agent liest aktuellen Dateizustand
    - Keine Kontext-Korruption mehr

DIE PHILOSOPHIE
---------------
Der Ralph Loop repraesentiert einen Paradigmenwechsel:

  ALT:
    - Perfekten Kontext beibehalten
    - Sorgfaeltig kuratieren was das LLM "erinnert"
    - Kontext-Management als Hauptproblem

  NEU (Ralph):
    - Fresh Starts umarmen
    - Git als Memory-Layer nutzen
    - "Naive Persistenz" - LLM wird gezwungen,
      seine eigenen Fehler zu konfrontieren

  Kernphilosophie:
    "Wenn du das Modell hart genug gegen seine eigenen Fehler
    drueckst, ohne Sicherheitsnetz, wird es irgendwann eine
    korrekte Loesung 'traeumen', nur um dem Loop zu entkommen."

PROBLEME DIE ES LOEST
---------------------
  1. Premature Exit
     LLM stoppt wenn es denkt "gut genug" statt objektiv fertig

  2. Single Prompt Fragility
     Ein Prompt reicht oft nicht fuer komplexe Aufgaben

  3. High Cost of Re-Prompting
     Manuelles Nachstossen ist teuer und muehsam

  4. Context Breakage
     Lange Sessions fuehren zu Kontext-Korruption

  5. Unreliable Self-Assessment
     LLMs bewerten sich selbst schlecht

OFFIZIELLE ADOPTION
-------------------
  Ende 2025: Boris Cherny (Anthropic's Head of Claude Code)
             formalisierte den Hack zum offiziellen ralph-wiggum Plugin

  Heute:     Implementiert in Claude Code, Cursor, und anderen Tools
             Von "interessantem Experiment" zu "legitimem Werkzeug"

IMPLEMENTIERUNGEN
-----------------
  Offiziell:
    - Claude Code: ralph-wiggum Plugin (Anthropic)
    - Cursor: Ralph Plugin

  Open Source:
    - github.com/snarktank/ralph
    - github.com/vercel-labs/ralph-loop-agent
    - The Ralph Playbook (claytonfarr.github.io)

BACH-RELEVANZ
-------------
Das Ralph-Pattern koennte fuer BACH interessant sein:

  1. Gemini CLI Auto-Modus
     - Bereits aehnliches Pattern: Loop mit STOPP nach N Tasks
     - Potenzial: Endlos-Loop bis _TASKS.md leer

  2. Claude Code Sessions
     - Mit --permission-mode bypassPermissions
     - Loop bis Aufgabe erledigt

  3. Headless AI-Sessions (ROADMAP Phase 9)
     - Ralph-Pattern als Grundlage fuer autonome Sessions
     - Git-basiertes Memory bereits vorhanden

BEISPIEL: MINIMALER RALPH LOOP
------------------------------
  #!/bin/bash
  # ralph.sh - Minimal Ralph Implementation

  PROMPT="Lies TASK.md, arbeite an offenen Items, committe Fortschritt."

  while true; do
    claude -p "$PROMPT"
    git add -A && git commit -m "Ralph iteration $(date +%H:%M)"
    sleep 5
  done

WANN RALPH NUTZEN?
------------------
  Gut geeignet:
    - Lange Coding-Sessions
    - PRD-zu-Code Implementierung
    - Bug-Hunting ueber viele Dateien
    - Refactoring-Projekte

  Weniger geeignet:
    - Einfache One-Shot-Aufgaben
    - Kreative/konzeptuelle Arbeit
    - Aufgaben die menschliches Urteil erfordern

RISIKEN & VORSICHT
------------------
  - Loop kann endlos laufen -> Budget-Limits setzen!
  - Ohne Aufsicht: unerwartete Aenderungen moeglich
  - Git-History kann schnell wachsen
  - "Naive Persistenz" kann zu merkwuerdigen Loesungen fuehren

NUETZLICHE LINKS
----------------
  Ralph Playbook:     https:/claytonfarr.github.io/ralph-playbook/
  Snarktank Ralph:    https:/github.com/snarktank/ralph
  Vercel Ralph:       https:/github.com/vercel-labs/ralph-loop-agent
  VentureBeat:        (Artikel ueber Ralph's Geschichte)

SIEHE AUCH
----------
  wiki/claude-code.txt    Claude Code CLI
  wiki/gemini.txt         Gemini CLI (aehnliches Pattern)
  ROADMAP.md Phase 9           Headless AI-Sessions
