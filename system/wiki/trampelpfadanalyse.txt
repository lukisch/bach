# Portabilitaet: UNIVERSAL
# Zuletzt validiert: 2026-02-15 (Claude)
# Naechste Pruefung: 2026-08-15
# Quellen: [Eigene Forschung], [Wikipedia: Desire Path]

TRAMPELPFADANALYSE (DESIRE PATH ANALYSIS)
==========================================

Stand: 2026-02-15

WAS IST DAS?
------------
Die Trampelpfadanalyse ist eine Methode aus der Landschaftsarchitektur und
dem UX-Design, adaptiert fuer LLM-Systeme. Man beobachtet wie naive Nutzer
(in unserem Fall: LLMs ohne Vorwissen) ein System navigieren, um zu
erkennen wo Orientierungshilfen fehlen.

Der Name kommt von den "Trampelpfaden" (engl. "Desire Paths") - informelle
Wege die ueber Rasenflaechen entstehen, weil Menschen dort laufen wo sie
tatsaechlich hin wollen, statt auf den geplanten Gehwegen.

ENGLISCHE BEGRIFFE
------------------
  Desire Path          Der haeufigste englische Begriff. Verwendet in
                       UX-Design, Stadtplanung, Architektur.

  Desire Line          Synonym, eher in der Verkehrsplanung.

  Cow Path             In der Software-Architektur: "Pave the cow paths"
                       bedeutet, die tatsaechlich genutzten Wege zu
                       formalisieren statt idealisierte Wege zu erzwingen.

  Elephant Path        Beste Metapher fuer LLMs: Elefanten trampeln breite,
                       unuebersehbare Pfade durch den Dschungel. Passt
                       perfekt - LLMs sind grosse, kraftvolle "Tiere" die
                       sichtbare Spuren im Dateisystem hinterlassen.

  Goat Track           Australisch/NZ: Schmaler, inoffizieller Pfad.

  Social Trail         Im Naturschutz: Pfade die von Wanderern abseits
                       offizieller Wege getreten werden.

URSPRUNG
--------
Das Konzept stammt aus der Landschaftsarchitektur. Der franzoesische
Philosoph Gaston Bachelard beschrieb es 1958. Praktisch angewendet wird es
seit den 1960ern: Architekten legen Rasen an, warten bis Trampelpfade
entstehen, und pflastern dann genau diese Wege.

Beruehmtes Beispiel: Der Campus der Michigan State University (USA) wurde
teilweise so geplant - Gehwege dort angelegt wo Studenten tatsaechlich
liefen.

In der Software-Entwicklung wurde der Begriff durch die Firma 37signals
(Basecamp/Rails) populaer: "Pave the cow paths" - statt Nutzer in
theoretische Workflows zu zwingen, die tatsaechlich genutzten Ablaeufe
unterstuetzen.

ANWENDUNG AUF LLM-SYSTEME
--------------------------
Adaptation fuer KI-Systeme (BACH, 2026):

  Statt Fussgaenger:    Naive LLMs (Haiku, Sonnet, etc.)
  Statt Rasenflaeche:   Dateisystem, API-Landschaft
  Statt Trampelpfad:    Navigations-Muster (besuchte Verzeichnisse)
  Statt Gehweg:         README, Docs, API-Dokumentation
  Statt Zaun:           Teaching-Hooks, Guardrails
  Statt Schild:         README.md, CLAUDE.md, Docstrings

Methodik:
  1. Naive LLMs ohne Vorwissen losschicken (verschiedene Auftraege)
  2. Ihre Navigation aufzeichnen (Pfad-Log)
  3. Heatmap erstellen (welche Verzeichnisse wie oft besucht)
  4. "Schilder" dort aufstellen wo sie fehlen
  5. Erneut messen ob die Navigation besser wird

ERGEBNISSE DES ERSTEN PILOTVERSUCHS (10 Proben)
-------------------------------------------------
10 Proben (5 Haiku + 5 Sonnet), verschiedene BACH-Auftraege:

  Meistbesucht (HOT):     hub/ (8/10), system/ (10/10)
  Gut besucht (WARM):     agents/ (6/10), data/ (6/10)
  Selten besucht (COOL):  tools/ (3/10), wiki/ (3/10)
  Nie besucht (COLD):     connectors/ (0/10), partners/ (0/10)

  Ergebnis: 4 READMEs erstellt, 1 Teaching-Hook installiert.
  Erfolgsquote: 100% (alle LLMs fanden ihren Weg)

Erkenntnisse:
  - hub/bach_paths.py wirkt wie ein natuerliches Inhaltsverzeichnis
  - Haiku navigiert direkt (find/ls), Sonnet exploriert breit (Glob)
  - MEMORY.md als Einstiegspunkt ist der effizienteste Shortcut
  - Leere Verzeichnisse verwirren (data/logs/)
  - Teaching-Hooks sind effektiver als reine Blockaden

ERGEBNISSE DES GROSSVERSUCHS (100 Proben)
------------------------------------------
100 naive Haiku-Proben, 20 verschiedene Tasks x 5 Wiederholungen.
Modus: Ohne MEMORY.md, ohne Skills, nur Bash/Glob/Grep/Read.
Dauer: 36.3 min, Kosten: $3.54, Parallelitaet: max 5 gleichzeitig.

  Status:   53 completed, 47 timeout (120s), 0 Fehler
  Pfade:    966 Referenzen, 566 unique
  Tools:    894 Aufrufe (54% Bash, 35% Read, 9% Glob, 3% Grep)

Verzeichnis-Heatmap:
  HOT  (30+):  root/ (68x), data/ (46x)
  WARM (10-29): hub/ (28x), wiki/ (21x), tools/ (12x), skills/ (11x),
                docs/ (11x), agents/ (10x), connectors/ (10x)
  COOL (1-9):  partners/ (9x), gui/ (1x), _templates/ (1x)
  COLD (0):    help/ (0x!) - KOMPLETT UNSICHTBAR trotz 93 Dateien!

Task-Erfolgsquoten:
  100%: BACH starten, Logs finden, Agenten auflisten, Nachrichten senden
   80%: Telegram-Bot, Wiki durchsuchen
   40%: Tasks erstellen, Python-Tools, System-Status
   20%: Steuerbelege, DB-Export
    0%: Neuen Skill erstellen (help/ und _protocols/ unsichtbar!)

Groesste Probleme:
  1. help/ nie besucht (0/100) - Hauptblindfleck
  2. Windows-Pfade: 53% aller Tool-Aufrufe mit Backslashes (fehlerhaft)
  3. skills/_protocols/ nur 2x besucht (nach Umbenennung von _workflows)
  4. Bash-Dominanz: ls statt Glob, find statt Grep

Massnahmen nach Grossversuch:
  - ARCHITECTURE.md: Schnellnavigation fuer LLMs hinzugefuegt (help/, wiki/ etc.)
  - ARCHITECTURE.md: Forward-Slash-Warnung ergaenzt
  - _templates/README.md: Self-Extension Referenz hinzugefuegt

SCHWARM-VERFAHREN (SWARM OPS)
------------------------------
Aufbauend auf der Trampelpfadanalyse: Muster fuer parallele LLM-Agenten.
Inspiriert von Schwarm-Robotik (Stigmergy, Ameisenkolonie-Optimierung).

  A. Echolot (Exploration)
     Viele naive Agenten erkunden parallel ein System. Jeder sammelt
     Pfade und Beobachtungen. Aggregation ergibt eine Heatmap.
     Anwendung: Trampelpfadanalyse, Audit, Discovery.

  B. Single Op (Race)
     Mehrere Agenten erhalten denselben Auftrag. Der Beste gewinnt.
     Anwendung: Optimierung, A/B-Tests, Quality-Gate.

  C. Ralphing (Pipeline)
     Worker erstellt, Reviewer prueft, Senior entscheidet.
     Anwendung: Code-Review, Dokumentation, Qualitaetssicherung.

  D. Nano-Swarm (Emergent)
     Viele Agenten mit einfachen Regeln, keine zentrale Steuerung.
     Kommunikation indirekt ueber Environment (Stigmergy):
     Gaestebuch-Dateien, Marker, Pheromon-Counter.
     Anwendung: Kollaborative Exploration, emergente Organisation.

  E. Schatzsuche (Health Check)
     Agenten navigieren Verzeichnisse, muessen dabei "Fallen"
     (korrupte Dateien, fehlende Rechte) erkennen und umgehen.
     Anwendung: System-Integritaet, Monitoring, Regression-Test.

VERWANDTE KONZEPTE
------------------
  UX Research         User-Beobachtung zur Verbesserung von Interfaces
  A/B Testing         Vergleich verschiedener Varianten
  Usability Testing   Beobachtung wie Nutzer Aufgaben loesen
  Instrumented Code   Code der seine eigene Nutzung aufzeichnet
  Heatmaps            Visualisierung von Nutzungsintensitaet
  Guardrails          Sicherheitsleitplanken fuer KI-Systeme

PHILOSOPHIE
-----------
"Erst den Rasen wachsen lassen, dann schauen wo die Leute laufen,
 dann dort den Weg pflastern."

Fuer LLM-Systeme: Nicht alles vorab perfekt dokumentieren, sondern
beobachten wo LLMs natuerlich hingehen und dort die Orientierung
verbessern. Das spart Dokumentationsaufwand und fokussiert ihn auf
die Stellen die tatsaechlich gebraucht werden.

SIEHE AUCH
----------
  skills/_protocols/trampelpfadanalyse.md   Protokoll v2.0 (inkl. Schwarm-Verfahren)
  data/elephant_path_launcher.py            Launcher-Script v6.0
  data/elephant_path_100/report.md          Grossversuch-Bericht (100 Proben)
  data/elephant_path_100/experiment.json    Experiment-Metadaten
  data/pilot_navigation_heatmap.md          Pilot-Heatmap (10 Proben)
  data/pilot_probe_report.md               Pilot-Bericht (10 Proben)
  wiki/mcp_toolstack.txt                   Verwandtes Thema (Tool-Discovery)
