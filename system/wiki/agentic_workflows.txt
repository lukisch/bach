# Portabilitaet: UNIVERSAL
# Zuletzt validiert: 2026-02-15 (Claude)
# Naechste Pruefung: 2026-08-15
# Quellen: [BACH ARCHITECTURE.md], [OpenAI Agentic Patterns], [ReAct Paper]

AGENTIC WORKFLOWS - ENTSCHEIDUNGSBASIERTE PROZESSE
===================================================

Stand: 2026-02-15

WAS IST EIN AGENTIC WORKFLOW?
-----------------------------
Ein Agentic Workflow ist ein strukturierter Prozess, bei dem ein KI-Agent autonome 
Entscheidungen trifft und iterativ ein Ziel verfolgt - im Gegensatz zu linearen 
Prompts. Der Agent hat Zugriff auf Tools, Kontext und Speicher, und kann seinen 
Handlungsablauf dynamisch anpassen basierend auf Zwischenergebnissen.

Kernmerkmale:
  * KOGNITIVES LOOP: Observe → Think → Act → Update Memory → Loop
  * TOOL-NUTZUNG: Agent waehlt aktiv aus verfuegbaren Tools (nicht einfache Prompts)
  * FEHLERBEHANDLUNG: Agent erkennt Fehlversuche und aendert Strategie
  * SPEICHER: Agent lernt aus vorherigen Versuchen (Session-, Facts-, Lessons-Memory)

UNTERSCHIED ZU TRADITIONALELLEN PROMPTS
---------------------------------------
Traditioneller Prompt:
  "Analysiere diese Datei und fasse das Ergebnis zusammen"
  → LLM gibt direkte Antwort (statisch)

Agentic Workflow:
  "Finde alle Fehler in der Codebase"
  → Agent entscheidet: "Ich brauche zuerst die Dateistruktur"
  → Agent liest Datei-Index
  → Agent waehlt relevante Dateien
  → Agent analysiert jede Datei schrittweise
  → Agent aktualisiert Lessons-Memory mit gefundenen Patterns
  → Agent gibt strukturierte Fehleranalyse zurueck

AGENTIC WORKFLOW PATTERNS IN BACH
----------------------------------

1. **ReAct-Loop (Reasoning + Acting)**
   Der Agent folgt diesem Muster:
   
   Thought: "Ich muss zuerst verstehen, was verlangt wird"
   Action:  "Tool: search_files('*.py')"
   Observation: "Fand 47 Python-Dateien"
   Thought: "Zu viele, ich brauche ein Filter-Kriterium"
   Action: "Tool: analyze_complexity(threshold=high)"
   Observation: "5 komplexe Dateien identifiziert"
   Thought: "Jetzt kann ich mit der Analyse starten"
   Action: "Tool: detailed_review(files=[...])"
   Result: [detaillierte Analyse]

2. **Tool-Chaining**
   Der Agent kombiniert mehrere Tools in sinnvoller Abfolge:
   
   Workflow: Dateiimport
     1. Tool "import_xlsx" → Extrahiere Daten
     2. Tool "validate_schema" → Pruefe Struktur
     3. Tool "enrich_data" → Verknuepfe mit DB
     4. Tool "generate_report" → Erstelle Zusammenfassung

3. **Fehlertoleranz-Loop**
   Der Agent erkennt Fehler und waehlt Alternative:
   
   Attempt 1: Verwende OCR auf PDF
   → Fehler: "PDF ist gescannt und schwer lesbar"
   → Analyse: "OCR hat <70% Genauigkeit"
   → Fallback: "Nutze manuellen Import-Assistenten"

4. **Inkrementelle Problemloesung**
   Statt alles auf einmal: schrittweise Annaeherung
   
   Task: "Optimiere diese SQL-Query"
   Step 1: Analysiere aktuelle Query-Performance
   Step 2: Identifiziere Bottlenecks
   Step 3: Vorschlag 1: Index hinzufuegen
   Step 4: Test Proposal 1
   Step 5: Evaluiere Ergebnis
   Step 6: Iteriere oder akzeptiere Loesung

MEMORY-INTEGRATION IN WORKFLOWS
-------------------------------
Der Agent nutzt verschiedene Memory-Typen strategisch:

  WORKING MEMORY:   "Was bin ich gerade am tun?" (aktuelle Iteration)
  FACTS MEMORY:     "Was habe ich gelernt?" (persistente Erkenntnisse)
  LESSONS MEMORY:   "Was funktioniert/funktioniert nicht?" (Best Practices)
  SESSION MEMORY:   "Was ist in dieser Sitzung passiert?" (Kontext)

Beispiel: Fehleranalyse-Workflow
  → Working: "Analysiere Datei X"
  → Lessons: "Bei Datei-Typ Y brauche ich Tool Z" (aus frueherem Versuch)
  → Facts: "Das Projekt nutzt Python 3.11" (Projektinfo)
  → Session: "Nutzer hat bereits 3 Fehler manuell gefixt" (Kontakt)

UNTERSCHIED: AGENTIC vs REAKTIV
------------------------------
Reaktiv (klassische LLM-Nutzung):
  User: "Finde alle TODO-Kommentare"
  LLM: Direkte Antwort (oder allgemeine Tipps)
  
Agentic (BACH-Ansatz):
  User: "Finde alle TODO-Kommentare"
  Agent: 
    1. "Ich muss die Codebase erkunden"
    2. Tool: "list_directories()" → findet Ordnerstruktur
    3. "Python/JS/Go-Code? Ich versuche zuerst Python"
    4. Tool: "search_pattern('TODO')" → 47 Ergebnisse
    5. Tool: "prioritize_by_impact()" → sortiert nach Wichtigkeit
    6. Agent liefert strukturierte Liste mit Context

HÄUFIGE AGENTIC WORKFLOW PATTERNS IN BACH
------------------------------------------

Pattern 1: DATA INGESTION WORKFLOW
  Datei auswählen → Schema validieren → In DB importieren 
  → Duplikate checken → Bericht generieren

Pattern 2: CODE REVIEW WORKFLOW
  Repository erkunden → Komplexität analysieren 
  → Sicherheits-Scan → Style-Check → Report mit Empfehlungen

Pattern 3: FINANCIAL ANALYSIS WORKFLOW
  Ausgaben kategorisieren → Trends berechnen 
  → Budgets vergleichen → Anomalien identifizieren → Visualisierung

Pattern 4: HEALTH TRACKING WORKFLOW
  Gesundheitsdaten importieren → Klassifizieren nach ICF 
  → Mit Therapie-Zielen abgleichen → Fortschritt berechnen 
  → Empfehlungen generieren

BEST PRACTICES FÜR AGENTIC WORKFLOWS
------------------------------------

1. EXPLIZITE DECISION POINTS
   Der Agent sollte klar entscheidungsfreudig sein:
   → "Ich habe 2 Optionen, ich waehle Option A weil..."
   
2. BEGRENZTE TIEFE (DEPTH LIMITING)
   Zu viele verschachtelte Entscheidungen = Kontextverlust
   → Max. 5-7 ReAct-Loops pro Workflow
   → Dann: Zwischenergebnis speichern & neu starten
   
3. TOOL-KATEGORISIERUNG
   Dem Agent klarmachen welche Tools in welcher Phase:
   → Phase 1 (Exploration): read, list, analyze-structure
   → Phase 2 (Processing): transform, validate, enrich
   → Phase 3 (Reporting): generate, export, notify

4. FAILURE MODES DOKUMENTIEREN
   Fuer jeden Workflow: Was soll passieren wenn es fehlschlaegt?
   → Automatischer Fallback
   → Benutzer-Benachrichtigung
   → Rollback

5. PROGRESS TRACKING
   Der Agent sollte seinen Fortschritt sichtbar machen:
   → "Schritt 3 von 7: Daten validieren..."
   → Ermoeglicht Benutzer-Intervention wenn noetig

SIEHE AUCH
----------
wiki/was_ist_bach.txt            BACH Systemueberblick
wiki/mcp.txt                     MCP und Tools-Integration
wiki/mcp_patterns.txt            Design-Patterns fuer MCP-Server
docs/ARCHITECTURE.md             Technische Implementierung
